COVER PAGE
______________________________________________________________________


CHESS APPLICATION

Charlie Mietzner -- clm133
Ritika Maknoor -- ritikamak
Peter Stamos -- petestamos
Rohan Patel (Scrum Master) --patelrohanv

10 November 2016

CS 1530 – SPRINT 4 DELIVERABLE





DESCRIPTION OF SPRINT
______________________________________________________________________


	We went into this sprint with a strong idea and grasp on what we wanted/needed to complete during it.  By this 4th sprint, we, as a team, had a general understanding on what we would most likely be capable of accomplishing in the two-week span.  Being the second to last sprint (next would be our last two-week span to develop the software and meet all of the requirements of the customer), we were nearing the end and had to be particularly focused and confident with every development.  Not only did we have our own goals, for this sprint ahead, that would help us continue on our path that led us through our progression of the project thus far; but also, we had new user stories from the customer that we had make our highest priority for our working version of software by the end of this sprint.  The customer changing their mind and introducing new user stories meant that we had to re-architect our code/design to meet these new needs.  
During our previous sprint’s retrospective, we noted what our strengths and weaknesses were- both individual and as a group.  We noticed that during our last sprint, we had very effective communication but wanted to improve on being more focused/committed to our specifically assigned user stories.  This was a difficult task because so many of the user stories overlapped in terms of functionalities of the application that were being manipulated.  Often times during the last sprint, time was wasted by multiple team members working on similar refactors of the same method.  Therefore, we decided that we needed to improve on being more strategic in how we divided up the user stories for the sprint.
	Our sprint planning session for this sprint was effective and efficient.  We discussed what we had completed so far- what components our “working software” had, and how close it was to meeting the end goal/all of the requirements for this product.  During our first sprint, we broke down our backlog of user stories into 3 categories (Chess GUI; Game Mechanics; Backend).  By the start of this 4th sprint, we had completed a large percentage of user stories from the Chess GUI category.  We had the interface of the application (visual display and channel for user interaction) almost completely set up.  We then discussed what the most logical next steps/our priorities should be for this sprint.  We went through our updated backlog of remaining/ incomplete user stories and chose our stories for the sprint.  We were able to do so rather quickly.  We divided them up amongst us, taking into consideration what domains and aspects of the development needed that each of us felt we were strongest and best fit to take on. 
	Throughout the entirety of the two-week span, we communicated very well.  Due to the fact that the group of user stories that we chose to complete were all very much connected/dependent on one another, we were all in almost constant contact.  The nature of the tasks that the user stories called for required manipulating one another’s code- i.e. abstracting away methods, organizing classes, synchronizing objects, etc.  We all actively communicated and were available whenever another teammate needed anything.  We were also better at commenting our code this sprint, which helped us all tremendously.  We did not have many disagreements.  The only issue that arose was the fact that so many of our user stories overlapped in terms of the code we were working on.  It was still difficult when multiple team members were working on the same classes (even though we tried to be more strategic in assigning user stories this sprint).  The majority of our user stories this time dealt with further developing the functionality of the pieces on the GUI (expanding the visuals, allowing user interaction, movement), and with initializing the backend of the game mechanics (legality of moves, swapping turns, flipping of the visual board for each turn swap).  However, we resolved this pretty well by communicating with each other about who would modify what they needed to first and who would do so second.  We were also particularly active with often merging our individually completed modifications to the master branch.  By doing so, we all always had the most up-to-date version of the code subsets.  After about the first week of the sprint, we, as a team, had a cohesive system for working on the code efficiently/effectively.  
	We did interact with the customer during this sprint when they provided us with modifications to their requirements for the software.  They provided us with 2 new and high priority user stories that in fact helped us understand what they, as the customer/user, wanted from the software in terms of graphics and visual capabilities.  After this 4th/current sprint, we have finally connected the GUI (display/platform for user interaction) with our backend of game mechanics (board and piece movements that deal with the actual algorithmic implementations of the rules of chess).  
At the end of this 4th sprint, we do indeed have completed/functional “working software”; however, this version of the software is not as functional in terms of GUI and game mechanics connection, as we had hoped for it to be by this point.  This sprint, we did not complete the user stories that dealt with the visual movement of the pieces from one square to another on the visual board.  We have the backend set-up so that it registers the clicks/desired movements of the user/player, but it is not yet programmed to support/display graphically a full game of chess.  We faced many challenged when writing our code to connect these two subsystems.  We were able to get the board to register all clicks/desired moves to be made on the board.  We were also able to get the program to check the legality of the moves attempted, and notify the player if an attempted move was actually illegal.  We were also able to get our application to take turns for which player’s moves would be logged next.  However, we had a lot of trouble getting the display of the pieces moving on the board to follow the moves being attempted.  We may have to refactor our code for the GUI during the next sprint to be able to support this extremely important functionality.  
Before our next sprint, we plan to consult our customer and show them our interactive graphical display.  We hope that in doing so, we will be able to gain an idea of the customer’s approval/disapproval of the development thus far.  Also, the customer will finally have the chance to interact with the GUI physically, which will make them/us more confident in our near-future final-product delivery.  We will perform user observations as we take note of how they interact with the system by default.  We hope that at that point, their feedback and our observations will provide us with a solid final understanding of the customer’s expectations before going into our final sprint.





LISTING OF COMPLETED USER STORIES & STORY POINTS
______________________________________________________________________


-	As a player
  I want the ability to flip the board,
  So that I can view the game from the perspective of the other player.
	STORY POINTS:  8
-	As a player
  I want the ability to change the colors of my pieces,
  So that I can play the game with a pleasing color scheme.
	STORY POINTS:  4
-	As a player
  I want the chess board to be at the top of the display window and any buttons to be at the bottom
  So that I see the chess board clearly while playing a game.
	STORY POINTS:  2
-	As a player
  I want to click anywhere in a square to execute a move to/from that square
  So that I am not restricted as to where I have to click.
	STORY POINTS:  2
-	As a player
  I want to first click a piece, then click its destination square, and then see the piece move to the indicated destination
  So that I can visually see that a move has been made.
	STORY POINTS:  8  (not completed)
-	As a player
  I want for there to be a list of all prior moves, on the side panel next to the game board
  So that moves can be kept track of during the game.
	STORY POINTS:  4  (not completed)
-	As a player
  I want white, and only white, to go first
  So that the program adheres to chess rules.
	STORY POINTS:  2
-	As a player
  I want turns to be taken (white/black/white/etc.),
  So that the game follows standard chess rules.
	STORY POINTS:  4
-	As a player
  I want pieces to not make illegal moves
  So that neither player can cheat.
	STORY POINTS:  16
-	As a player
  I want an error message to appear if I try to make an illegal move
  So that illegal moves are blocked from occurring.
	STORY POINTS:  8 
-	As a player
  I want the board to be organized so that no 2 pieces can ever occupy the same square
  So that the game follows standard chess rules.
	STORY POINTS:  4
-	As a player
  I want special movements to be legal- such as “en passant”, “promotion”, and “castling” 
  So that the game follows standard chess rules.
	STORY POINTS:  2  (not completed)
TOTAL VELOCIY = 50





LINK TO CODE ON GITHUB
______________________________________________________________________


On GitHub: https://github.com/clm133/CS1530groupproject





LISTING OF DEFECTS
______________________________________________________________________


SUMMARY: 
The change color button only works before any moves are made.
DESCRIPTION:
The player can chance the colors for both the black and white chess pieces. This however only works properly when it is done before any moves are made. If colors are switched after a move has been made it does not change all pieces.
REPRODUCTION STEPS:
1.	Run the chess program
2.	Click a white piece and move it to any legal destination
3.	Attempt to switch colors for the pieces via the button
EXPECTED BEHAVIOR:
The button should change colors for all pieces of that player whenever the button is clicked.
OBSERVED BEHAVIOR:
Piece colors only change if the color changes are made before any pieces have been moved. If a piece has been moved not all pieces will change color.
NOTES:
This problem was fixed by refactoring the code and properly linking the GUI to the backend.

                                    _________________________________      


SUMMARY: 
The flip board button only work before any moves are made.
DESCRIPTION:
The player can flip the board to see it from the white player’s or the black player’s perspective. This however only works properly when it is done before any moves are made. If one attempts to flip the board after the first piece is moved it causes an error where only some of the pieces are flipped.
REPRODUCTION STEPS:
1.	Run the chess program
2.	Click a white piece and move it to any legal destination
3.	Attempt to flip the board via the button.
EXPECTED BEHAVIOR:
The button should flip the board whenever the button is clicked.
OBSERVED BEHAVIOR:
The board will only properly flip before any pieces have been moved. If a piece has been moved not all pieces will end up in their correctly flipped position.
NOTES:
This problem is related to other defects in this sprint that relate to linked the GUI to the backend. This was fixed by refactoring the code to properly link the GUI and backend.

                                    _________________________________      


SUMMARY: 
The white pieces can move but the board does not switch to black after a move is made.
DESCRIPTION:
The player can move a white piece on the first turn but the game does not flip the board and switch to black after that move has been made.
REPRODUCTION STEPS:
1.	Run the chess program.
2.	Attempt to move a move any white piece to a legal location.
EXPECTED BEHAVIOR:
The GUI should end the turn, flip the board, and allow black pieces to move. 
OBSERVED BEHAVIOR:
A white piece is moved but the board does not flip nor does it allow black pieces to move.
NOTES:
This can be fixed by changing the backend to stop all movement for a specific color after a single piece is moved. This will be made a priority in the next sprint.

                                    _________________________________      


SUMMARY: 
White pieces can currently capture squares currently occupied by white pieces. 
DESCRIPTION:
The player can make a move and be told whether or not the move is legal or not. The player is also forced to adhere to standard Chess turns where white moves and is then proceeded by black. The GUI however does not properly update with each move. 
REPRODUCTION STEPS:
1.	Run the chess program
2.	Attempt to move a white piece to any legal location occupied by another white piece. 
EXPECTED BEHAVIOR:
The GUI should not move the piece to that location.
OBSERVED BEHAVIOR:
The piece can occupy the square captured by that piece even though both are the same color.
NOTES:
This can be fixed by changing the move piece method for each class to verify that the piece being captured is an enemy. This will be made a priority in the next sprint.

                                    _________________________________      


SUMMARY: 
The testCastle_1 to testCastle_5 test in the KingTest.java class fail.
DESCRIPTION:
Castling with the path being impeded is illegal in Chess but the program does not return false when attempting to make the move.  
REPRODUCTION STEPS:
1.	Run gradle -test
EXPECTED BEHAVIOR:
These tests should pass.
OBSERVED BEHAVIOR:
These tests result in failed tests.
NOTES:
This problem looks like it be fixed by refactoring the implementation of movePiece for the King class and having the Chess class validate the path for castling is not impeded, the destination is not occupied, and that the king never passes through a check while castling. This can most likely be fixed once StockFish is properly linked with our program.
